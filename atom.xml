<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小果的个人博客</title>
  
  
  <link href="http://guo1zy.github.io/atom.xml" rel="self"/>
  
  <link href="http://guo1zy.github.io/"/>
  <updated>2024-04-15T13:06:34.551Z</updated>
  <id>http://guo1zy.github.io/</id>
  
  <author>
    <name>小果</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>opencv入门</title>
    <link href="http://guo1zy.github.io/2024/04/14/opencv%E5%85%A5%E9%97%A8/"/>
    <id>http://guo1zy.github.io/2024/04/14/opencv%E5%85%A5%E9%97%A8/</id>
    <published>2024-04-14T14:44:26.000Z</published>
    <updated>2024-04-15T13:06:34.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="培训1opencv基础学习笔记"><a class="markdownIt-Anchor" href="#培训1opencv基础学习笔记"></a> 培训1——OpenCV基础学习笔记</h1><p><u>本文是基于本人在电子科技大学ROBOCON 比赛LImiti战队期间学习笔记</u></p><h2 id="0-安装opencv"><a class="markdownIt-Anchor" href="#0-安装opencv"></a> 0. 安装OpenCV</h2><p>（详细安装过程csdn上搜索即可）</p><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libopencv-dev</span><br></pre></td></tr></table></figure><p>或者 使用源码安装</p><p>如果在终端运行的操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make </span><br><span class="line">./xxxx(the excutable file that you create)</span><br></pre></td></tr></table></figure><p>内嵌到vscode  下载插件：c/c++  cmake tools   c/c++ compile run</p><hr /><br/><h2 id="1-任务1mat"><a class="markdownIt-Anchor" href="#1-任务1mat"></a> 1. 任务1——Mat</h2><p>在电脑中随便选择一张图片，使用imread读取该图片，并使用imshow可视化该图片</p><ul><li><p><strong>要求</strong>：掌握OpenCV基础Mat类型，使用cmake编译并运行</p><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span><span class="comment">//包含库</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取图片</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/zy/pictures/12.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否成功读取图片</span></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;<span class="comment">//empty返回值为1，执行以下程序</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法读取图片&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个窗口并显示图片</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待用户按下任意键后关闭窗口</span></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><hr /><p>OpenCV（Open Source Computer Vision Library）开源计算机视觉库中的 cv::Mat 是一个非常重要的类，它用于表示图像和图像处理中的矩阵数据。这是OpenCV中的核心数据结构之一，用于处理图像和图像数据。以下是 cv::Mat 的一些基本解释：</p><p>1.图像和矩阵的通用容器：cv::Mat 是OpenCV中的通用容器，用于存储图像、矩阵和多维数组等数据。它可以存储单通道和多通道的图像，以及任意维度的数值矩阵。</p><p>2.数据表示：cv::Mat 表示的数据是多维的，通常是2D（图像）或3D（彩色图像）的。每个元素可以是整数、浮点数、复数等数据类型，具体取决于您的需求。</p><p>3.图像处理：cv::Mat 提供了许多函数和方法，用于在图像处理中进行各种操作，例如图像加载、保存、剪裁、调整大小、过滤、转换、绘制等。</p><p>4.通道和颜色空间：对于彩色图像，cv::Mat 可以存储多个通道，每个通道代表不同的颜色通道（如红、绿、蓝）。您可以轻松地在不同颜色空间之间转换，例如从BGR到HSV。</p><p>5.访问像素值：您可以使用 at 或 ptr 方法来访问 cv::Mat 中像素的值，这让您可以读取和修改图像中的像素数据。</p><p>6.内存管理：cv::Mat 采用智能指针管理内存，因此在大多数情况下，您无需手动释放内存。当 cv::Mat 对象超出作用域时，内存将自动释放。</p><p>7.图像大小和类型：cv::Mat 包含有关图像大小和数据类型的信息，这使得在处理图像时非常方便，您可以轻松地获取图像的宽度、高度、通道数和数据类型。</p><p>8.灰度图像和彩色图像：cv::Mat 可以用于表示灰度图像（单通道图像）和彩色图像（多通道图像）。</p><p>例如访问其像素值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个3x3的灰度图像</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">grayImage</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, CV_8UC1)</span></span>; <span class="comment">// CV_8UC1表示8位无符号单通道图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置像素值</span></span><br><span class="line">    grayImage.<span class="built_in">at</span>&lt;uchar&gt;(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">100</span>;</span><br><span class="line">    grayImage.<span class="built_in">at</span>&lt;uchar&gt;(<span class="number">1</span>, <span class="number">1</span>) = <span class="number">200</span>;</span><br><span class="line">    grayImage.<span class="built_in">at</span>&lt;uchar&gt;(<span class="number">2</span>, <span class="number">2</span>) = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问像素值</span></span><br><span class="line">    uchar pixelValue = grayImage.<span class="built_in">at</span>&lt;uchar&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pixel Value at (1,1): &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(pixelValue) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr /><br/><h2 id="2任务2摄像头和颜色"><a class="markdownIt-Anchor" href="#2任务2摄像头和颜色"></a> 2.任务2——摄像头和颜色</h2><p>使用VideoCapture打开一个摄像头</p><p>可以是电脑自带摄像头，也可以是usb外接摄像头（如果都没有，请参考<a href="./IP%E6%91%84%E5%83%8F%E5%A4%B4%E8%B0%83%E7%94%A8%E6%89%8B%E6%9C%BA%E6%91%84%E5%83%8F%E5%A4%B4.md"><strong>IP摄像头调用手机摄像头.md</strong></a> ）,或者使用队里的大的相机。</p><p>实时捕获摄像头图像数据，并将图片色彩空间转换到HSV色彩空间，实时提取出摄像头图像数据中的红色、蓝色、白色</p><ul><li><p><strong>要求</strong>：学会调用摄像头捕获图像，并了解RGB、HSV等色彩空间，基于色彩空间学会颜色提取</p></li><li><hr /></li><li><p>内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开摄像头</span></span><br><span class="line">    <span class="function">cv::VideoCapture <span class="title">cap</span><span class="params">(<span class="string">&quot;http://192.168.50.88:8081&quot;</span>)</span></span>;<span class="comment">//手机ip</span></span><br><span class="line">   <span class="comment">// cd::VideoCapture cap(0);//电脑自带摄像头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查摄像头是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (!cap.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开摄像头&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat frame;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取一帧图像</span></span><br><span class="line">        cap &gt;&gt; frame;</span><br><span class="line"></span><br><span class="line">        cv::Mat result1;</span><br><span class="line">        cv::Mat result2;</span><br><span class="line">        cv::Mat result3;<span class="comment">//初始化</span></span><br><span class="line">        <span class="comment">// 调整图像尺寸为更小的尺寸</span></span><br><span class="line">        <span class="function">cv::Size <span class="title">smallSize</span><span class="params">(<span class="number">640</span>, <span class="number">480</span>)</span></span>; <span class="comment">// 设置目标尺寸</span></span><br><span class="line">        cv::<span class="built_in">resize</span>(frame, frame, smallSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换色彩空间为HSV</span></span><br><span class="line">        cv::Mat hsv;</span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(frame, hsv, cv::COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义红色范围</span></span><br><span class="line">        <span class="function">cv::Scalar <span class="title">lower_red</span><span class="params">(<span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">        <span class="function">cv::Scalar <span class="title">upper_red</span><span class="params">(<span class="number">180</span>, <span class="number">255</span>, <span class="number">255</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义蓝色范围</span></span><br><span class="line">        <span class="function">cv::Scalar <span class="title">lower_blue</span><span class="params">(<span class="number">90</span>, <span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">        <span class="function">cv::Scalar <span class="title">upper_blue</span><span class="params">(<span class="number">150</span>, <span class="number">255</span>, <span class="number">255</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义白色范围</span></span><br><span class="line">        <span class="function">cv::Scalar <span class="title">lower_white</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">        <span class="function">cv::Scalar <span class="title">upper_white</span><span class="params">(<span class="number">255</span>, <span class="number">30</span>, <span class="number">255</span>)</span></span>;<span class="comment">//需要根据色盘来确定，</span></span><br><span class="line">        <span class="comment">//不同地方的取值范围不同</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取红色、蓝色和白色</span></span><br><span class="line">        cv::Mat mask_red, mask_blue, mask_white;</span><br><span class="line">        cv::<span class="built_in">inRange</span>(hsv, lower_red, upper_red, mask_red);</span><br><span class="line">        cv::<span class="built_in">inRange</span>(hsv, lower_blue, upper_blue, mask_blue);</span><br><span class="line">        cv::<span class="built_in">inRange</span>(hsv, lower_white, upper_white, mask_white);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整颜色提取结果的尺寸</span></span><br><span class="line">        cv::<span class="built_in">resize</span>(mask_red, mask_red, smallSize);</span><br><span class="line">        cv::<span class="built_in">resize</span>(mask_blue, mask_blue, smallSize);</span><br><span class="line">        cv::<span class="built_in">resize</span>(mask_white, mask_white, smallSize);</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">bitwise_and</span>(frame, frame, result1, mask_red);</span><br><span class="line">        cv::<span class="built_in">bitwise_and</span>(frame, frame, result2, mask_blue);</span><br><span class="line">        cv::<span class="built_in">bitwise_and</span>(frame, frame, result3, mask_white);</span><br><span class="line">        <span class="comment">////将结果加上颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示原始图像和颜色提取结果</span></span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Camera&quot;</span>, frame);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Red&quot;</span>, result1);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Blue&quot;</span>, result2);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;White&quot;</span>, result3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待用户按下ESC键后退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">1</span>) == <span class="number">27</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭摄像头</span></span><br><span class="line">    cap.<span class="built_in">release</span>();</span><br><span class="line">    cv::<span class="built_in">destroyAllWindows</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>在其中，读取每一帧的图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat frame;</span><br><span class="line">cap &gt;&gt; frame; <span class="comment">// 读取一帧图像</span></span><br></pre></td></tr></table></figure><h3 id="转换色彩空间"><a class="markdownIt-Anchor" href="#转换色彩空间"></a> 转换色彩空间：</h3><h3 id="cvcvtcolor"><a class="markdownIt-Anchor" href="#cvcvtcolor"></a> cv::cvtColor</h3><p>函数用于将图像从一种色彩空间转换为另一种色彩空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">cvtColor</span>(src, dst, code);</span><br></pre></td></tr></table></figure><p>src：输入图像，要将其从一个色彩空间转换为另一个色彩空间。<br />dst：输出图像，转换后的图像将存储在这里。<br />code：色彩空间转换代码，指定要执行的具体转换。例如，cv::COLOR_BGR2GRAY 表示将BGR色彩空间转换为灰度色彩空间。</p><p>以下是一些常见的 code 值和它们的含义：</p><p>cv::COLOR_BGR2GRAY：将BGR色彩空间转换为灰度色彩空间。<br />cv::COLOR_BGR2HSV：将BGR色彩空间转换为HSV色彩空间。<br />cv::COLOR_BGR2Lab：将BGR色彩空间转换为Lab色彩空间。<br />cv::COLOR_HSV2BGR：将HSV色彩空间转换回BGR色彩空间。<br />cv::COLOR_GRAY2BGR：将灰度色彩空间转换为BGR色彩空间，通常用于将灰度图像转换为彩色图像。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat inputImage = cv::<span class="built_in">imread</span>(<span class="string">&quot;input.jpg&quot;</span>);</span><br><span class="line">cv::Mat grayImage;</span><br><span class="line"></span><br><span class="line">cv::<span class="built_in">cvtColor</span>(inputImage, grayImage, cv::COLOR_BGR2GRAY);</span><br></pre></td></tr></table></figure><hr /><h3 id="cvinrange"><a class="markdownIt-Anchor" href="#cvinrange"></a> cv::inRange</h3><p>函数用于在图像中提取指定范围内的像素值，并将范围内的像素设置为白色，范围外的像素设置为黑色。这个函数通常用于颜色分割和掩码操作，以便从图像中提取特定颜色的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">inRange</span>(src, lowerBound, upperBound, dst);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">src：输入图像，从该图像中提取像素值。</span></span><br><span class="line"><span class="comment">lowerBound：指定范围的下界。这是一个包含了颜色的向量，表示颜色的最小值。</span></span><br><span class="line"><span class="comment">upperBound：指定范围的上界。这是一个包含了颜色的向量，表示颜色的最大值。</span></span><br><span class="line"><span class="comment">dst：输出图像，结果图像，范围内的像素为白色（255），</span></span><br><span class="line"><span class="comment">范围外的像素为黑色（0）。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat inputImage = cv::<span class="built_in">imread</span>(<span class="string">&quot;input.jpg&quot;</span>);</span><br><span class="line">cv::Mat mask; <span class="comment">// 输出的掩码图像</span></span><br><span class="line"></span><br><span class="line"><span class="function">cv::Scalar <span class="title">lowerRed</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 红色的下界（B, G, R）</span></span><br><span class="line"><span class="function">cv::Scalar <span class="title">upperRed</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>, <span class="number">255</span>)</span></span>; <span class="comment">// 红色的上界（B, G, R）</span></span><br><span class="line"></span><br><span class="line">cv::<span class="built_in">inRange</span>(inputImage, lowerRed, upperRed, mask);</span><br></pre></td></tr></table></figure><hr /><h3 id="cvbitwise_and"><a class="markdownIt-Anchor" href="#cvbitwise_and"></a> cv::bitwise_and</h3><p>函数用于执行位逻辑与操作，它可以将两个二进制图像进行逐位的与操作。这个函数通常用于图像处理中的掩码操作，其中一个二进制图像用于指定哪些像素需要保留，另一个用于指定哪些像素需要删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">bitwise_and</span>(src1, src2, dst, mask);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">src1：第一个输入图像。</span></span><br><span class="line"><span class="comment">src2：第二个输入图像。</span></span><br><span class="line"><span class="comment">dst：输出图像，结果图像，将 src1 和 src2 进行逐位的与操作后的图像。</span></span><br><span class="line"><span class="comment">mask：可选参数，用于指定逻辑与操作的掩码图像。如果提供了掩码图像，</span></span><br><span class="line"><span class="comment">仅当掩码图像中对应像素的值为非零时，才会执行逻辑与操作；</span></span><br><span class="line"><span class="comment">否则，结果像素为零。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br/><hr /><br/><h2 id="3-任务3形态学操作"><a class="markdownIt-Anchor" href="#3-任务3形态学操作"></a> 3. 任务3——形态学操作</h2><p>学习一些形态学操作，如膨胀、腐蚀、开运算、闭运算等</p><p>学习边缘提取（如Canny）和<code>findContours</code>函数，在任务二的基础上，实时提取出红色、蓝色、白色的轮廓，且利用形态学操作消除一些噪点（或一些面积过小的色块）</p><ul><li><strong>要求</strong>：学会基础的形态学操作，辅助消除图像噪声等</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">// 打开摄像头，您也可以使用图像文件</span></span><br><span class="line">    <span class="keyword">if</span> (!cap.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error: Camera not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Mat frame;</span><br><span class="line">        cap &gt;&gt; frame;</span><br><span class="line">        <span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Error: Frame is empty.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Mat hsv_frame;</span><br><span class="line">        <span class="built_in">cvtColor</span>(frame, hsv_frame, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义红色、蓝色和白色的颜色范围</span></span><br><span class="line">        <span class="function">Scalar <span class="title">lower_red</span><span class="params">(<span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">upper_red</span><span class="params">(<span class="number">10</span>, <span class="number">255</span>, <span class="number">255</span>)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">lower_blue</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">upper_blue</span><span class="params">(<span class="number">130</span>, <span class="number">255</span>, <span class="number">255</span>)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">lower_white</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">upper_white</span><span class="params">(<span class="number">255</span>, <span class="number">30</span>, <span class="number">255</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        Mat mask_red, mask_blue, mask_white;</span><br><span class="line">        <span class="built_in">inRange</span>(hsv_frame, lower_red, upper_red, mask_red);</span><br><span class="line">        <span class="built_in">inRange</span>(hsv_frame, lower_blue, upper_blue, mask_blue);</span><br><span class="line">        <span class="built_in">inRange</span>(hsv_frame, lower_white, upper_white, mask_white);</span><br><span class="line"></span><br><span class="line">        Mat result;</span><br><span class="line">        <span class="built_in">bitwise_or</span>(mask_red, mask_blue, result);</span><br><span class="line">        <span class="built_in">bitwise_or</span>(result, mask_white, result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 形态学操作</span></span><br><span class="line">        Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line">        <span class="built_in">morphologyEx</span>(result, result, MORPH_OPEN, kernel);</span><br><span class="line">        <span class="built_in">morphologyEx</span>(result, result, MORPH_CLOSE, kernel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找轮廓</span></span><br><span class="line">        vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">        <span class="built_in">findContours</span>(result, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line">        <span class="comment">//开，闭运算</span></span><br><span class="line">        <span class="comment">// 绘制轮廓</span></span><br><span class="line">        Mat contour_frame = frame.<span class="built_in">clone</span>();</span><br><span class="line">        <span class="built_in">drawContours</span>(contour_frame, contours, <span class="number">-1</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Original Frame&quot;</span>, frame);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Processed Frame&quot;</span>, contour_frame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">waitKey</span>(<span class="number">10</span>) == <span class="number">27</span>)  <span class="comment">// 按ESC键退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h3 id="膨胀dilation"><a class="markdownIt-Anchor" href="#膨胀dilation"></a> 膨胀（Dilation）：</h3><p>膨胀操作可以扩展图像中的白色区域，通常用于填充图像中的小空洞或连接相邻对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cv::Mat input_image = cv::<span class="built_in">imread</span>(<span class="string">&quot;input_image.png&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (input_image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Cannot read the input image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat dilated_image;</span><br><span class="line">cv::Mat kernel = cv::<span class="built_in">getStructuringElement</span>(cv::MORPH_RECT, cv::<span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>));  </span><br><span class="line">    <span class="comment">// 定义膨胀内核</span></span><br><span class="line">    cv::<span class="built_in">dilate</span>(input_image, dilated_image, kernel);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Input Image&quot;</span>, input_image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Dilated Image&quot;</span>, dilated_image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h3 id="cvgetstructuringelement"><a class="markdownIt-Anchor" href="#cvgetstructuringelement"></a> cv::getStructuringElement</h3><p>函数用于创建用于形态学操作（例如腐蚀和膨胀）的结构元素。在你提供的代码中，创建了一个矩形结构元素 kernel，其大小为5x5像素，用于形态学操作。</p><p>这个结构元素可以用于执行形态学操作，例如图像腐蚀和膨胀，以及其他基于结构元素的图像处理操作。</p><p><strong>cv::MORPH_RECT</strong> 表示你创建的结构元素是一个矩形。<br />**cv::Size(5, 5) **指定了矩形的尺寸，宽度为5像素，高度为5像素。<br />你可以将这个 kernel 结构元素传递给形态学操作的函数，例如 cv::erode（腐蚀）和 cv::dilate（膨胀），以执行图像处理任务。这个结构元素将定义操作的卷积核，用于定义操作的影响范围。通常，矩形结构元素用于形态学操作，但你也可以创建其他形状的结构元素，如椭圆形或十字形，以满足特定的图像处理需求。</p><br/><h3 id="腐蚀erosion"><a class="markdownIt-Anchor" href="#腐蚀erosion"></a> 腐蚀（Erosion）：</h3><p>腐蚀操作可以减小图像中的白色区域，通常用于去除小的噪声或分离相邻对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat input_image = cv::<span class="built_in">imread</span>(<span class="string">&quot;input_image.png&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (input_image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Cannot read the input image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat eroded_image;</span><br><span class="line">    cv::Mat kernel = cv::<span class="built_in">getStructuringElement</span>(cv::MORPH_RECT, cv::<span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>));  <span class="comment">// 定义腐蚀内核</span></span><br><span class="line">    cv::<span class="built_in">erode</span>(input_image, eroded_image, kernel);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Input Image&quot;</span>, input_image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Eroded Image&quot;</span>, eroded_image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开运算opening"><a class="markdownIt-Anchor" href="#开运算opening"></a> 开运算（Opening）：</h3><p>开运算是腐蚀操作后紧接着膨胀操作的组合。它通常用于去除小的噪声，以及分离相邻对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat input_image = cv::<span class="built_in">imread</span>(<span class="string">&quot;input_image.png&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (input_image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Cannot read the input image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat opened_image;</span><br><span class="line">    cv::Mat kernel = cv::<span class="built_in">getStructuringElement</span>(cv::MORPH_RECT, cv::<span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>));  <span class="comment">// 定义内核</span></span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(input_image, opened_image, cv::MORPH_OPEN, kernel);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Input Image&quot;</span>, input_image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Opened Image&quot;</span>, opened_image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="闭运算closing"><a class="markdownIt-Anchor" href="#闭运算closing"></a> 闭运算（Closing）：</h3><p>闭运算是膨胀操作后紧接着腐蚀操作的组合。它通常用于关闭对象之间的小空隙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat input_image = cv::<span class="built_in">imread</span>(<span class="string">&quot;input_image.png&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (input_image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Cannot read the input image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat closed_image;</span><br><span class="line">    cv::Mat kernel = cv::<span class="built_in">getStructuringElement</span>(cv::MORPH_RECT, cv::<span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>));  <span class="comment">// 定义内核</span></span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(input_image, closed_image, cv::MORPH_CLOSE, kernel);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Input Image&quot;</span>, input_image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Closed Image&quot;</span>, closed_image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4任务4使用鼠标指针交互来获取图片的某点的rgb值"><a class="markdownIt-Anchor" href="#4任务4使用鼠标指针交互来获取图片的某点的rgb值"></a> 4.任务4–使用鼠标指针交互来获取图片的某点的rgb值</h2><p>自己学习如何制作鼠标指针回调来得到当前图片当前点的信息</p><p>’    要求：学会可以使用鼠标回调得到当前点的的三通道（rgb或hsv）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Mat image;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onMouse</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span>* param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event == EVENT_LBUTTONDOWN) &#123;<span class="comment">//EVENT_LBUTTONDOWN 鼠标左键</span></span><br><span class="line">        Vec3b pixel = image.<span class="built_in">at</span>&lt;Vec3b&gt;(y, x);  <span class="comment">// 获取像素值</span></span><br><span class="line"><span class="comment">//上行代码从图像 image 中获取了鼠标单击位置 (x, y) 处的像素值。</span></span><br><span class="line">        <span class="type">int</span> blue = pixel[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> green = pixel[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> red = pixel[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;RGB at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;): &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;R=&quot;</span> &lt;&lt; red &lt;&lt; <span class="string">&quot;, G=&quot;</span> &lt;&lt; green &lt;&lt; <span class="string">&quot;, B=&quot;</span> &lt;&lt; blue &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    image = <span class="built_in">imread</span>(<span class="string">&quot;your_image.jpg&quot;</span>);  <span class="comment">// 读取图像</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error: Image not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Image&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setMouseCallback</span>(<span class="string">&quot;Image&quot;</span>, onMouse, <span class="literal">NULL</span>);  <span class="comment">// 设置鼠标回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">destroyAllWindows</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一旦使用 setMouseCallback 函数将窗口与回调函数关联起来，当用户在名为 “Image” 的窗口上进行鼠标操作（如单击、移动等）时，onMouse 回调函数将会被调用，并根据鼠标事件的类型执行相应的操作。这允许您实现交互式图像处理，例如在图像上单击以获取像素值或执行其他操作。</p><br/><h2 id="5任务5对图像进行均衡化处理伽马变化以及图像滤波等常见的变化"><a class="markdownIt-Anchor" href="#5任务5对图像进行均衡化处理伽马变化以及图像滤波等常见的变化"></a> 5.任务5–对图像进行均衡化处理，伽马变化，以及图像滤波等常见的变化</h2><p>自己查询常见的处理方式和函数（均衡化，伽马变化，高斯模糊，以及几种常见的滤波器）</p><p>‘ 要求：学会常见对图像进行的方式和函数，包括不限于上述提到的基本算法</p><h3 id="直方图均衡化histogram-equalization"><a class="markdownIt-Anchor" href="#直方图均衡化histogram-equalization"></a> 直方图均衡化（Histogram Equalization）：</h3><p>直方图均衡化用于<strong>增强图像的对比度</strong>，特别是在图像中存在大范围亮度变化时。它通过重新分布像素值来拉伸图像的直方图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> cv::Mat input_image = cv::<span class="built_in">imread</span>(<span class="string">&quot;input_image.jpg&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (input_image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Cannot read the input image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat equalized_image;</span><br><span class="line">    cv::<span class="built_in">equalizeHist</span>(input_image, equalized_image);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Input Image&quot;</span>, input_image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Equalized Image&quot;</span>, equalized_image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伽马变化gamma-correction"><a class="markdownIt-Anchor" href="#伽马变化gamma-correction"></a> 伽马变化（Gamma Correction）：</h3><p>伽马变化用于<strong>调整图像的亮度和对比度</strong>，以更好地显示特定亮度区域的细节。它通过应用幂函数来改变像素的强度值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat input_image = cv::<span class="built_in">imread</span>(<span class="string">&quot;input_image.jpg&quot;</span>, cv::IMREAD_COLOR);</span><br><span class="line">    <span class="keyword">if</span> (input_image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Cannot read the input image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> gamma = <span class="number">1.5</span>; <span class="comment">// 伽马值，可以调整以增强或减弱图像对比度</span></span><br><span class="line">    cv::Mat gamma_corrected_image;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">lookup_table</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8U)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        lookup_table.<span class="built_in">at</span>&lt;uchar&gt;(<span class="number">0</span>, i) = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(<span class="built_in">pow</span>(i / <span class="number">255.0</span>, gamma) * <span class="number">255.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">LUT</span>(input_image, lookup_table, gamma_corrected_image);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Input Image&quot;</span>, input_image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Gamma Corrected Image&quot;</span>, gamma_corrected_image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>伽马变化是通过应用以下公式来实现的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output_pixel_value = input_pixel_value^gamma</span><br></pre></td></tr></table></figure><p>其中 output_pixel_value 是变换后的像素值，input_pixel_value 是输入像素值，而 gamma 是伽马值。通过调整 gamma 值，您可以增强或减弱图像的对比度。</p><p>当 gamma &lt; 1.0 时，图像的低亮度区域将更亮，高亮度区域将更暗，对比度降低。<br />当 gamma &gt; 1.0 时，图像的低亮度区域将更暗，高亮度区域将更亮，对比度增加。<br />当 gamma = 1.0 时，变换无效，图像保持原样。<br />通过调整 gamma 值，您可以根据需要调整图像的明暗程度和对比度，以满足不同的视觉效果要求。在示例代码中，gamma 被设置为 1.5，这会导致对比度增加，使图像的亮部更亮，暗部更暗。您可以尝试不同的 gamma 值来观察不同的效果。</p><hr /><h3 id="高斯模糊gaussian-blur"><a class="markdownIt-Anchor" href="#高斯模糊gaussian-blur"></a> 高斯模糊（Gaussian Blur）：</h3><p>高斯模糊用于降低图像噪声并平滑图像。它基于高斯滤波核来进行模糊操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat input_image = cv::<span class="built_in">imread</span>(<span class="string">&quot;input_image.jpg&quot;</span>, cv::IMREAD_COLOR);</span><br><span class="line">    <span class="keyword">if</span> (input_image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Cannot read the input image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat blurred_image;</span><br><span class="line">    cv::<span class="built_in">GaussianBlur</span>(input_image, blurred_image, cv::<span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Input Image&quot;</span>, input_image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Blurred Image&quot;</span>, blurred_image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="cvgaussianblur"><a class="markdownIt-Anchor" href="#cvgaussianblur"></a> cv::GaussianBlur</h3><p>函数用于在图像上应用高斯模糊，以减少噪声和平滑图像。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">GaussianBlur</span>(input_image, blurred_image, cv::<span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>input_image：这是输入图像，您希望对其进行高斯模糊处理的图像。通常，它是一个OpenCV的 cv::Mat 对象。</p><p>blurred_image：这是输出图像，它将包含经过高斯模糊处理后的图像。同样，它也是一个 cv::Mat 对象，通常会在函数调用之前进行初始化。</p><p>cv::Size(5, 5)：这是高斯滤波核的大小，它决定了模糊程度。在这个示例中，使用了一个 5x5 的核。核的大小越大，模糊效果越明显，噪声减少，但图像细节也可能丧失。</p><p>0：这是高斯滤波的X和Y方向的标准差。如果将其设置为0，OpenCV将根据核的大小自动计算标准差。如果需要更精确的控制，可以指定非零值。</p><p>cv::GaussianBlur 函数会将高斯滤波应用于输入图像，然后将结果存储在输出图像 blurred_image 中。高斯模糊是一种常用的图像平滑技术，可用于去除噪声、减少细节和平滑图像。通过调整核的大小和标准差，您可以控制模糊的程度。</p><br/><h3 id="图像滤波image-filtering"><a class="markdownIt-Anchor" href="#图像滤波image-filtering"></a> 图像滤波（Image Filtering）：</h3><p>图像滤波是一种用于<strong>去噪、增强边缘、模糊等操作的常见技术</strong>。OpenCV提供了多种滤波函数，包括<strong>均值滤波</strong>、<strong>中值滤波</strong>和自定<strong>义卷积核滤波</strong>等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat input_image = cv::<span class="built_in">imread</span>(<span class="string">&quot;input_image.jpg&quot;</span>, cv::IMREAD_COLOR);</span><br><span class="line">    <span class="keyword">if</span> (input_image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Cannot read the input image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat filtered_image;</span><br><span class="line">    cv::Mat kernel = (cv::<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">8</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>); <span class="comment">// 自定义卷积核</span></span><br><span class="line">    cv::<span class="built_in">filter2D</span>(input_image, filtered_image, <span class="number">-1</span>, kernel);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Input Image&quot;</span>, input_image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Filtered Image&quot;</span>, filtered_image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cv::Mat kernel：这是自定义的卷积核，它是一个 cv::Mat 对象，</span></span><br><span class="line"><span class="comment">表示卷积核的权重矩阵。在这个示例中，卷积核是一个3x3的矩阵，</span></span><br><span class="line"><span class="comment">其中心元素为8，周围元素为-1，用于增强图像中的边缘特征。</span></span><br><span class="line"><span class="comment">您可以根据需要设计不同的卷积核来实现不同的滤波效果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cv::filter2D(input_image, filtered_image, -1, kernel)：</span></span><br><span class="line"><span class="comment">这是应用卷积操作的部分。cv::filter2D 函数用于将自定义卷积核</span></span><br><span class="line"><span class="comment">kernel 应用于输入图像 input_image，并将结果存储在 filtered_image 中。</span></span><br><span class="line"><span class="comment">参数 -1 表示输出图像的深度（与输入图像相同的深度）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这段代码的目的是使用自定义卷积核对输入图像进行卷积，</span></span><br><span class="line"><span class="comment">以实现特定的图像处理效果。在这个示例中，</span></span><br><span class="line"><span class="comment">卷积核被设计为增强图像中的边缘特征。根据不同的卷积核设计，</span></span><br><span class="line"><span class="comment">您可以实现不同的滤波效果，如边缘检测、锐化、模糊等。</span></span><br><span class="line"><span class="comment">卷积是图像处理中的常见操作，用于提取图像的不同特征。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="相关检测的核"><a class="markdownIt-Anchor" href="#相关检测的核"></a> 相关检测的核：</h3><h3 id="边缘检测"><a class="markdownIt-Anchor" href="#边缘检测"></a> 边缘检测：</h3><p>1.Sobel 卷积核：用于检测图像中的边缘，分为水平和垂直方向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Horizontal Sobel Kernel:</span><br><span class="line">-1  -2  -1</span><br><span class="line"> 0   0   0</span><br><span class="line"> 1   2   1</span><br><span class="line"></span><br><span class="line">Vertical Sobel Kernel:</span><br><span class="line">-1   0   1</span><br><span class="line">-2   0   2</span><br><span class="line">-1   0   1</span><br></pre></td></tr></table></figure><p>2.Scharr 卷积核：与Sobel类似，但对边缘更敏感。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Horizontal Scharr Kernel:</span><br><span class="line">-3  -10  -3</span><br><span class="line">  0   0   0</span><br><span class="line">  3   10  3</span><br><span class="line"></span><br><span class="line">Vertical Scharr Kernel:</span><br><span class="line">-3   0   3</span><br><span class="line">-10  0   10</span><br><span class="line">-3   0   3</span><br></pre></td></tr></table></figure><h3 id="锐化"><a class="markdownIt-Anchor" href="#锐化"></a> 锐化：</h3><p>1.Laplacian 卷积核：用于增强图像的高频细节，从而实现锐化效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Laplacian Kernel:</span><br><span class="line"> 0   1   0</span><br><span class="line"> 1  -4   1</span><br><span class="line"> 0   1   0</span><br></pre></td></tr></table></figure><h3 id="模糊"><a class="markdownIt-Anchor" href="#模糊"></a> 模糊：</h3><p>均值模糊（平均模糊）：用于平滑图像，消除噪声。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3x3 均值模糊 Kernel:</span><br><span class="line"> 1/9  1/9  1/9</span><br><span class="line"> 1/9  1/9  1/9</span><br><span class="line"> 1/9  1/9  1/9</span><br></pre></td></tr></table></figure><p>高斯模糊：用于平滑图像，但更加柔和，能够保留一些边缘细节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3x3 高斯模糊 Kernal：</span><br><span class="line">-1  -1  -1</span><br><span class="line">-1   8  -1</span><br><span class="line">-1  -1  -1</span><br></pre></td></tr></table></figure><p>通常使用OpenCV的 cv::filter2D 函数来应用卷积操作。</p><hr /><br/><h2 id="6霍夫找圆和角点检测"><a class="markdownIt-Anchor" href="#6霍夫找圆和角点检测"></a> 6.霍夫找圆和角点检测</h2><p>学习霍夫直线和角点的函数，</p><p>’要求：可以使用相关的函数来检测圆和角点来检测图片，找出给定图片里面的三角，圆和正方形。</p><h3 id="霍夫圆检测"><a class="markdownIt-Anchor" href="#霍夫圆检测"></a> 霍夫圆检测：</h3><p>霍夫圆检测用于在图像中检测圆形物体。您可以使用 cv::HoughCircles 函数来执行霍夫圆检测。原理概述：</p><p>需要检测的圆可以用以下数学方程表示：(x - a)^2 + (y - b)^2 = r^2，其中 (a, b) 是圆心的坐标，r 是圆的半径。</p><p>对于每个可能的 (a, b, r) 组合，可以在图像中寻找相应的边缘点。这些边缘点应当与圆上的点非常接近。</p><p>在累加器数组（Hough Accumulator）中，为每个可能的 (a, b, r) 组合投票。如果有足够多的边缘点投票给特定的 (a, b, r)，则认为找到了一个圆。</p><p>最后，通过分析累加器数组来找到得票最多的圆，然后输出检测到的圆的信息，包括圆心坐标和半径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;input_image.jpg&quot;</span>, cv::IMREAD_COLOR);</span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Cannot read the input image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat gray_image;</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(image, gray_image, cv::COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 霍夫圆检测</span></span><br><span class="line">    std::vector&lt;cv::Vec3f&gt; circles;</span><br><span class="line">    cv::<span class="built_in">HoughCircles</span>(gray_image, circles, cv::HOUGH_GRADIENT, <span class="number">1</span>, gray_image.rows / <span class="number">8</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制检测到的圆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; circles.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="function">cv::Point <span class="title">center</span><span class="params">(cvRound(circles[i][<span class="number">0</span>]), cvRound(circles[i][<span class="number">1</span>]))</span></span>;</span><br><span class="line">        <span class="type">int</span> radius = <span class="built_in">cvRound</span>(circles[i][<span class="number">2</span>]);</span><br><span class="line">        cv::<span class="built_in">circle</span>(image, center, radius, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Detected Circles&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="cvhoughcircles"><a class="markdownIt-Anchor" href="#cvhoughcircles"></a> cv::HoughCircles</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">HoughCircles</span>(</span><br><span class="line">    input_image,     <span class="comment">// 输入灰度图像</span></span><br><span class="line">    circles,         <span class="comment">// 存储检测到的圆的容器</span></span><br><span class="line">    cv::HOUGH_GRADIENT, <span class="comment">// 霍夫变换方法</span></span><br><span class="line">    dp,              <span class="comment">// 累加器图像的分辨率，通常设置为1</span></span><br><span class="line">    minDist,         <span class="comment">// 圆心之间的最小距离，通常设置为图像高度的八分之一</span></span><br><span class="line">    param1,          <span class="comment">// Canny边缘检测器的高阈值</span></span><br><span class="line">    param2,          <span class="comment">// 至少要有多少个投票才能认为检测到一个圆</span></span><br><span class="line">    minRadius,       <span class="comment">// 最小半径</span></span><br><span class="line">    maxRadius        <span class="comment">// 最大半径，如果设置为0，函数将自动计算</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;cv::Vec3f&gt; circles;</span><br><span class="line">cv::<span class="built_in">HoughCircles</span>(gray_image, circles, cv::HOUGH_GRADIENT, <span class="number">1</span>, gray_image.rows / <span class="number">8</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>std::vector<a href="cv::Vec3f">cv::Vec3f</a> circles：这是一个用于存储检测到的圆的容器。每个检测到的圆都由一个 cv::Vec3f 对象表示，其中包含圆的中心坐标 (x, y) 和半径。</p><p>cv::HoughCircles 函数执行霍夫圆检测。它的参数如下：</p><p>gray_image：这是输入的灰度图像，通常是由彩色图像转换而来。</p><p>circles：这是用于存储检测到的圆的容器。</p><p>cv::HOUGH_GRADIENT：这是霍夫变换的方法，表示使用梯度法进行圆检测。</p><p>1：表示霍夫圆检测的累加器图像的分辨率，通常设置为1。</p><p>gray_image.rows / 8：圆心之间的最小距离，通常设置为图像高度的八分之一。</p><p>200：Canny边缘检测器的高阈值。</p><p>100：表示至少要有多少个投票才能认为检测到一个圆。</p><p>0：表示霍夫圆检测的最小半径。</p><p>0：表示霍夫圆检测的最大半径。如果设置为0，函数将根据图像尺寸自动计算最大半径。</p><p>cv::HoughCircles 函数会在输入的灰度图像上执行霍夫圆检测，并将检测到的圆的信息存储在 circles 容器中。您可以遍历 circles 容器来访问每个检测到的圆的位置和半径信息，然后在图像上绘制这些圆以进行可视化显示。</p><hr /><h3 id="角点检测"><a class="markdownIt-Anchor" href="#角点检测"></a> 角点检测：</h3><p>角点检测（Corner Detection）是计算机视觉中的一项重要任务，用于检测图像中的角点或角落区域。角点通常是图像中的显著特征点，具有在不同方向上发生明显弯曲的特性。角点检测的原理是寻找图像中的局部最大弯曲或局部最小特征值的位置。</p><p>原理概述：</p><p>角点通常位于图像中的边缘交汇或曲线的交点附近。这些点在不同方向上的梯度变化较大，因此梯度矩阵的特征值可以用来检测它们。</p><p>对于每个像素点，计算其周围邻域的梯度信息，通常使用<strong>Sobel、Harris或Shi-Tomasi等算子。</strong></p><p>计算梯度矩阵的特征值（最小特征值和最大特征值）或角点响应函数。</p><p>根据特征值的阈值或相对大小，选择具有较大特征值的像素点，这些点被认为是图像中的角点。</p><p>通常还会对检测到的角点进行非极大值抑制，以去除冗余的角点。</p><p>OpenCV 提供了多种角点检测方法，其中包括 Harris 角点检测、Shi-Tomasi 角点检测和 FAST 角点检测等。</p><p>角点检测用于检测图像中的角点，例如检测三角形的顶点。您可以使用 cv::goodFeaturesToTrack 函数来执行角点检测。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;input_image.jpg&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Cannot read the input image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;cv::Point2f&gt; corners;<span class="comment">//检测到的角点</span></span><br><span class="line">    cv::<span class="built_in">goodFeaturesToTrack</span>(image, corners, <span class="number">100</span>, <span class="number">0.01</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制检测到的角点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; corners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cv::<span class="built_in">circle</span>(image, corners[i], <span class="number">5</span>, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Detected Corners&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cv::goodFeaturesToTrack 函数来执行角点检测。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::goodFeaturesToTrack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    cv::InputArray image,     <span class="comment">// 输入图像，通常是灰度图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cv::OutputArray corners, <span class="comment">// 输出检测到的角点</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> maxCorners,          <span class="comment">// 最大角点数目，要检测到的角点数量的上限</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> qualityLevel,     <span class="comment">// 角点质量因子，通常在0.01到0.1之间</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> minDistance,      <span class="comment">// 角点之间的最小距离，两个角点之间的距离必须大于这个值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cv::InputArray mask = cv::noArray(), <span class="comment">// 可选的掩码，指定检测区域</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> blockSize = <span class="number">3</span>,       <span class="comment">// 计算角点响应函数所使用的邻域块的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> useHarrisDetector = <span class="literal">false</span>,     <span class="comment">// 是否使用Harris角点检测方法，如果为true，则使用Harris角点检测，否则使用Shi-Tomasi</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> k = <span class="number">0.04</span>           <span class="comment">// Harris角点检测参数，仅在useHarrisDetector为true时有效</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sobel-harris-和-shi-tomasi"><a class="markdownIt-Anchor" href="#sobel-harris-和-shi-tomasi"></a> **Sobel、Harris 和 Shi-Tomasi **</h3><p>都是图像处理和计算机视觉领域中常用的算子，用于不同的任务，如边缘检测和角点检测。</p><p>Sobel 算子：</p><p>Sobel 算子是一种用于边缘检测的算子。它通过计算图像中每个像素点的梯度来寻找图像中的边缘。Sobel 算子通常应用于灰度图像。<br />Sobel 算子分为水平和垂直两个方向的核，分别用于检测图像中的水平和垂直边缘。<br />梯度的大小和方向可用于确定边缘的位置和强度。<br />Harris 角点检测：</p><p>Harris 角点检测是用于检测图像中的角点的算法。它基于像素点周围邻域的强度变化来检测角点。<br />Harris 角点检测使用局部窗口内的像素值来计算一个角点响应函数，该函数考虑了窗口内像素值的变化。当这个响应函数达到最大值时，表示在该位置检测到一个角点。<br />Harris 角点检测通常用于特征匹配和跟踪。<br />Shi-Tomasi 角点检测：</p><p>Shi-Tomasi 角点检测是与 Harris 角点检测类似的算法，也用于检测图像中的角点。它改进了 Harris 角点检测的角点选择准则。<br />Shi-Tomasi 角点检测使用最小特征值来评估角点的质量。当最小特征值大于某个阈值时，才被认为是一个角点。<br />Shi-Tomasi 角点检测常常被视为 Harris 角点检测的改进版本，通常在计算机视觉中更常用。</p><hr /><h2 id="7-透视变换"><a class="markdownIt-Anchor" href="#7-透视变换"></a> 7. 透视变换</h2><p>学习掌握透视变换的原理</p><p>重点掌握<code>getPerspectiveTransform</code>和<code>warpPerspective</code>两个函数，拍摄一个物体（如A4纸），并利用透视变换校正视角为正视该物体</p><ul><li><strong>要求</strong>：学会利用透视变换获取不同的视角</li></ul><p>透视变换是一种图像处理技术，用于将图像从一个透视或投影视图转换为另一个视图，以校正图像中的透视畸变或改变观察角度。在这个任务中，您想要拍摄一个物体（例如A4纸），并使用透视变换来校正视角，使物体呈现正视图。</p><p>以下是执行透视变换的一般步骤：</p><p><strong>拍摄物体图像</strong>：首先，您需要拍摄物体的图像，例如A4纸。确保在拍摄时，物体位于透视图中，可能会出现一些透视畸变。</p><p><strong>确定四个关键点</strong>：在图像上标记四个关键点，这些点对应于物体的四个角。这四个点用于定义透视变换。</p><p><strong>计算透视变换矩阵</strong>：使用 cv::getPerspectiveTransform 函数计算透视变换矩阵。这个函数需要输入源图像上的四个关键点和目标图像上的四个对应点，然后返回变换矩阵。</p><p><strong>应用透视变换</strong>：使用 cv::warpPerspective 函数将图像应用于透视变换矩阵，以校正透视畸变并获得正视图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;object_image.jpg&quot;</span>); <span class="comment">// 读取物体图像</span></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Cannot read the input image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在图像上标记四个关键点（物体的四个角）</span></span><br><span class="line">    std::vector&lt;cv::Point2f&gt; src_points;</span><br><span class="line">    src_points.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 左上角</span></span><br><span class="line">    src_points.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(image.cols, <span class="number">0</span>)); <span class="comment">// 右上角</span></span><br><span class="line">    src_points.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(image.cols, image.rows)); <span class="comment">// 右下角</span></span><br><span class="line">    src_points.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(<span class="number">0</span>, image.rows)); <span class="comment">// 左下角</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目标图像上定义对应的四个点</span></span><br><span class="line">    std::vector&lt;cv::Point2f&gt; dst_points;</span><br><span class="line">    dst_points.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 左上角</span></span><br><span class="line">    dst_points.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(image.cols, <span class="number">0</span>)); <span class="comment">// 右上角</span></span><br><span class="line">    dst_points.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(image.cols * <span class="number">1.5</span>, image.rows)); <span class="comment">// 右下角</span></span><br><span class="line">    dst_points.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(-image.cols * <span class="number">0.5</span>, image.rows)); <span class="comment">// 左下角</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算透视变换矩阵</span></span><br><span class="line">    cv::Mat perspective_matrix = cv::<span class="built_in">getPerspectiveTransform</span>(src_points, dst_points);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用透视变换</span></span><br><span class="line">    cv::Mat corrected_image;</span><br><span class="line">    cv::<span class="built_in">warpPerspective</span>(image, corrected_image, perspective_matrix, image.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示原始图像和校正后的图像</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Corrected Image&quot;</span>, corrected_image);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br/><h3 id="cvwarpperspective"><a class="markdownIt-Anchor" href="#cvwarpperspective"></a> cv::warpPerspective</h3><p>用于应用透视变换矩阵到图像，以实现透视校正或视角变换。这个函数接受输入图像和透视变换矩阵，并返回经过变换后的图像。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::warpPerspective</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    cv::InputArray src,         <span class="comment">// 输入图像，通常是要进行透视变换的图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cv::OutputArray dst,        <span class="comment">// 输出图像，用于存储变换后的图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cv::InputArray M,           <span class="comment">// 3x3透视变换矩阵</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cv::Size dsize,             <span class="comment">// 输出图像的尺寸</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> flags = cv::INTER_LINEAR, <span class="comment">// 插值方法，通常使用线性插值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> borderMode = cv::BORDER_CONSTANT, <span class="comment">// 边界模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> cv::Scalar&amp; borderValue = cv::Scalar() <span class="comment">// 边界值</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><p>src：输入图像，通常是要进行透视变换的图像。</p><p>dst：输出图像，用于存储变换后的图像。它应该是一个预先分配的空图像。</p><p>M：3x3透视变换矩阵，通常是使用 cv::getPerspectiveTransform 函数计算得到的。</p><p>dsize：输出图像的尺寸，通常是一个 cv::Size 结构，指定输出图像的宽度和高度。</p><p>flags：插值方法，用于确定如何在变换过程中处理像素值。通常使用线性插值 (cv::INTER_LINEAR) 来获得平滑的结果。</p><p>borderMode：边界模式，用于确定如何处理超出图像边界的像素。默认是 cv::BORDER_CONSTANT，意味着超出边界的像素将使用指定的 borderValue 进行填充。</p><p>borderValue：边界值，当 borderMode 设置为 cv::BORDER_CONSTANT 时使用的像素值。</p><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat input_image = cv::<span class="built_in">imread</span>(<span class="string">&quot;input_image.jpg&quot;</span>); <span class="comment">// 读取输入图像</span></span><br><span class="line">cv::Mat perspective_matrix; <span class="comment">// 透视变换矩阵，通常使用 cv::getPerspectiveTransform 计算得到</span></span><br><span class="line"></span><br><span class="line">cv::Mat output_image; <span class="comment">// 用于存储变换后的图像</span></span><br><span class="line"><span class="function">cv::Size <span class="title">output_size</span><span class="params">(width, height)</span></span>; <span class="comment">// 输出图像的尺寸</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用透视变换</span></span><br><span class="line">cv::<span class="built_in">warpPerspective</span>(input_image, output_image, perspective_matrix, output_size, cv::INTER_LINEAR, cv::BORDER_CONSTANT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出图像保存到文件或显示</span></span><br><span class="line">cv::<span class="built_in">imwrite</span>(<span class="string">&quot;output_image.jpg&quot;</span>, output_image);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-查阅学习几个坐标系"><a class="markdownIt-Anchor" href="#8-查阅学习几个坐标系"></a> 8. 查阅学习几个坐标系</h2><p>自行查阅资料，了解图像坐标系、像素坐标系、相机坐标系、世界坐标系等几个坐标系之间的变换关系</p><p>要求：理解其相对的关系</p><p>在计算机视觉和图像处理领域，有几个常用的坐标系，它们之间存在一些变换关系。以下是几个常见的坐标系以及它们之间的关系：</p><h3 id="1图像坐标系image-coordinate-system"><a class="markdownIt-Anchor" href="#1图像坐标系image-coordinate-system"></a> 1.图像坐标系（Image Coordinate System）：</h3><p>图像坐标系是最常见的坐标系之一，用于表示图像中的像素位置。它通常以图像的左上角为原点，水平向右为X轴正方向，垂直向下为Y轴正方向。<br />像素坐标系（Pixel Coordinate System）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">O————————————————————————————————————————————————————————————————&gt;X轴</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">V</span><br><span class="line">Y轴</span><br></pre></td></tr></table></figure><h3 id="2像素坐标系"><a class="markdownIt-Anchor" href="#2像素坐标系"></a> 2.像素坐标系</h3><p>是图像坐标系的一种特殊形式，其中每个像素都有一个唯一的坐标。它通常以左上角的像素为 (0,0) 坐标，然后向右增加列数，向下增加行数。</p><h3 id="3相机坐标系camera-coordinate-system"><a class="markdownIt-Anchor" href="#3相机坐标系camera-coordinate-system"></a> 3.相机坐标系（Camera Coordinate System）：</h3><p>相机坐标系用于表示相机的内部参数和外部参数。它通常以<strong>相机的光学中心为原点</strong>，X轴<strong>指向相机的右侧，Y轴指向相机的下方，Z轴指向相机的前方</strong>。相机坐标系通常用于相机校准和计算摄像机姿态等任务。<br />世界坐标系（World Coordinate System）：</p><h3 id="4世界坐标系"><a class="markdownIt-Anchor" href="#4世界坐标系"></a> 4.世界坐标系</h3><p>是用于表示场景中物体位置的坐标系。它通常以场景中的某一固定点为原点，X、Y、Z 轴分别指向场景中的某个方向。世界坐标系通常用于进行<strong>三维重建和物体定位等任务</strong>。</p><h3 id="关系和变换"><a class="markdownIt-Anchor" href="#关系和变换"></a> 关系和变换：</h3><p>图像坐标系和像素坐标系之间的关系通常是一一对应的，其中图像坐标系中的点 (x, y) 对应于像素坐标系中的点 (i, j)，其中** i 和 j 是整数像素坐标**。</p><p>相机坐标系和世界坐标系之间的变换通常是通过相机的内部参数（如焦距和主点）以及外部参数（如相机位置和姿态）来实现的。这个变换关系通常称为相机的外部和内部参数矩阵。</p><p>相机坐标系中的点可以通过相机的内部和外部参数变换到世界坐标系中，从而实现从相机坐标系到世界坐标系的变换。</p><p>图像坐标系通常与相机坐标系之间也有一个变换关系，可以通过相机的投影矩阵来实现。这个变换将相机坐标系中的点投影到图像坐标系中。</p><br/><h2 id="9-学习相机成像原理和对相机进行标定"><a class="markdownIt-Anchor" href="#9-学习相机成像原理和对相机进行标定"></a> 9. 学习相机成像原理和对相机进行标定</h2><p>自己在网上学习相机成像的原理，然后再搜索标定相机的方法，结合所学到得到相机成像的原理（一般使用的matlab来对其进行标定</p><p>要求：可以自主完成相机标定任务。</p><p><strong>相机成像原理：</strong></p><p><strong>针孔相机模型</strong>：了解针孔相机模型是理解相机成像原理的关键。根据该模型，光线通过相机的针孔（光圈）进入相机并投射在感光元件（例如CCD或CMOS传感器）上，从而形成图像。</p><p><strong>透镜和焦距</strong>：理解透镜的作用，透镜的焦距决定了相机的视场和对焦深度。</p><p><strong>成像平面</strong>：感光元件的表面被称为成像平面，它用于捕捉光线的图像。</p><p><strong>成像过程</strong>：了解光线如何通过透镜和针孔进入相机，以及如何在成像平面上形成图像。学习如何通过光线追踪来理解图像形成过程。</p><p><strong>相机标定</strong>：</p><p><strong>标定目的</strong>：确定相机的内部参数和外部参数，以便在图像中准确地测量物体的尺寸和位置。</p><p><strong>内部参数</strong>：内部参数包括焦距、主点坐标、镜头畸变等。通常，这些参数是相机制造商提供的，但在某些情况下需要进行重新标定。</p><p><strong>外部参数</strong>：外部参数包括相机的位置和朝向。这些参数通常需要在标定过程中估计。</p><p><strong>标定模式</strong>：选择合适的标定模式，如单目相机、双目相机或立体视觉系统。</p><p><strong>标定板</strong>：使用特定的标定板（如棋盘格）来拍摄图像，以获取标定所需的数据。</p><p><strong>图像采集</strong>：拍摄一系列包含标定板的图像，确保标定板在不同位置和朝向下都能够被捕捉到。</p><p><strong>标定算法</strong>：使用相机标定算法，如Zhang’s标定方法或Tsai’s标定方法，从图像数据中估计相机的内部和外部参数。</p><p><strong>结果验证</strong>：对标定结果进行验证，通常使用残差分析来评估标定的准确性。</p><p>应用：一旦完成相机标定，您可以将标定参数应用于图像测量、摄像机运动估计、立体视觉等领域。</p><p>在标定相机时，通常使用专门的标定工具或库，如OpenCV，它提供了一组用于相机标定的函数和工具。您可以使用这些工具来获取标定所需的参数。</p><p>请注意，相机标定是一个复杂的任务，需要一定的数学和计算机视觉知识。建议您查阅相关文档、教程和示例代码，以更深入地了解相机成像原理和标定方法，并在实践中逐步掌握这些技能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;培训1opencv基础学习笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#培训1opencv基础学习笔记&quot;&gt;&lt;/a&gt; 培训1——OpenCV基础学习笔记&lt;/h1&gt;
&lt;p&gt;&lt;u&gt;本文是基于本人在电子科技大学ROBOCON 比赛LImi</summary>
      
    
    
    
    <category term="视觉" scheme="http://guo1zy.github.io/categories/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="视觉" scheme="http://guo1zy.github.io/tags/%E8%A7%86%E8%A7%89/"/>
    
    <category term="opencv" scheme="http://guo1zy.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://guo1zy.github.io/2024/04/14/hello-world/"/>
    <id>http://guo1zy.github.io/2024/04/14/hello-world/</id>
    <published>2024-04-13T18:02:05.931Z</published>
    <updated>2024-04-15T13:17:47.768Z</updated>
    
    <content type="html"><![CDATA[<p>快速入门Hexo ~~~~~~~~~</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;快速入门Hexo ~~~~~~~~~&lt;/p&gt;
&lt;h2 id=&quot;quick-start&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#quick-start&quot;&gt;&lt;/a&gt; Quick Start&lt;/h2&gt;
&lt;h3 id=&quot;create-a-new-p</summary>
      
    
    
    
    
  </entry>
  
</feed>
